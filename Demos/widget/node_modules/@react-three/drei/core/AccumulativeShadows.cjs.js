"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@babel/runtime/helpers/extends"),t=require("three"),r=require("react"),a=require("@react-three/fiber");function i(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function n(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var a=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,a.get?a:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var s=i(e),o=n(t),u=n(r);const l=u.createContext(null),c=u.forwardRef((({children:e,blend:t,frames:r=40,scale:i=10,temporal:n=!1,opacity:s=1,alphaTest:c=.65,color:h="black",resolution:f=1024,...g},p)=>{const m=a.useThree((e=>e.gl)),v=a.useThree((e=>e.scene)),M=a.useThree((e=>e.camera)),b=u.useRef(null),y=u.useRef(null),S=u.useRef(0),[w]=u.useState((()=>new d(m,v,f)));u.useLayoutEffect((()=>{w.configureObject(b.current)}),[]),r<=1&&(r=2);let L=void 0===t&&r===1/0?100:r;const _=u.useMemo((()=>{const e=Object.assign(new o.MeshBasicMaterial({opacity:0,transparent:!0,dithering:!0,depthWrite:!1,map:w.progressiveLightMap2.texture}),{uniforms:{ucolor:{value:new o.Color(h)},alphaTest:{value:0}}});return e.onBeforeCompile=t=>{e.uniforms=t.uniforms={...t.uniforms,...e.uniforms},t.fragmentShader=t.fragmentShader.replace("void main() {","uniform vec3 ucolor;\n           uniform float alphaTest;\n           void main() {"),t.fragmentShader=t.fragmentShader.replace("#include <dithering_fragment>","#include <dithering_fragment>\n           gl_FragColor = vec4(ucolor * gl_FragColor.r * 2.0, max(0.0, (1.0 - gl_FragColor.r / alphaTest)) * opacity);")},e}),[h]),[T,x]=u.useState([]);function E(e=1){n?(_.opacity=Math.min(s,_.opacity+s/L),_.uniforms.alphaTest.value=Math.min(c,_.uniforms.alphaTest.value+c/L)):(_.opacity=s,_.uniforms.alphaTest.value=c),y.current.visible=!0;const t=[];v.traverse((e=>{(function(e){return e.isLight})(e)&&(t.push({object:e,intensity:e.intensity}),e.intensity=0)}));for(let t=0;t<e;t++)w.update(M,L),T&&T.forEach((e=>e.update()));y.current.visible=!1,t.forEach((({object:e,intensity:t})=>e.intensity=t))}function C(){r!==1/0&&(w.clear(),_.opacity=0,_.uniforms.alphaTest.value=0,S.current=0,E())}const A=u.useMemo((()=>({reset:C,update:E,setLights:x})),[]);return u.useImperativeHandle(p,(()=>A),[A]),a.useFrame((()=>{n&&S.current<r&&(E(),S.current++)})),u.useLayoutEffect((()=>{C(),n||E(L)})),u.createElement("group",g,u.createElement("group",{traverse:()=>null,ref:y},u.createElement(l.Provider,{value:A},e)),u.createElement("mesh",{receiveShadow:!0,ref:b,material:_,scale:i,rotation:[-Math.PI/2,0,0]},u.createElement("planeGeometry",null)))})),h=u.forwardRef((({castShadow:e=!0,bias:t=0,mapSize:r=512,size:a=5,near:i=.5,far:n=500,frames:c=1,position:h=[0,0,0],radius:d=1,amount:f=8,intensity:g=1,ambient:p=.5,...m},v)=>{const M=u.useRef(null),b=new o.Vector3(...h).length(),y=u.useContext(l),S=u.useCallback((()=>{let e;if(M.current)for(let t=0;t<M.current.children.length;t++)if(e=M.current.children[t],Math.random()>p)e.position.set(h[0]+o.MathUtils.randFloatSpread(d),h[1]+o.MathUtils.randFloatSpread(d),h[2]+o.MathUtils.randFloatSpread(d));else{let t=Math.acos(2*Math.random()-1)-Math.PI/2,r=2*Math.PI*Math.random();e.position.set(Math.cos(t)*Math.cos(r)*b,Math.abs(Math.cos(t)*Math.sin(r)*b),Math.sin(t)*b)}}),[d,p,b,...h]),w=u.useMemo((()=>({update:S})),[S]);return u.useImperativeHandle(v,(()=>w),[w]),u.useLayoutEffect((()=>(y&&y.setLights((e=>[...e,w])),()=>y.setLights((e=>e.filter((e=>e!==w)))))),[y,w]),u.createElement("group",s.default({ref:M},m),Array.from({length:f},((s,o)=>u.createElement("directionalLight",{key:o,castShadow:e,"shadow-bias":t,"shadow-mapSize":[r,r],intensity:g/f},u.createElement("orthographicCamera",{attach:"shadow-camera",args:[-a,a,a,-a,i,n]})))))}));class d{constructor(e,t,r=1024){this.renderer=e,this.res=r,this.scene=t,this.scene.background=null,this.buffer1Active=!1;const a=/(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent)?o.HalfFloatType:o.FloatType;this.progressiveLightMap1=new o.WebGLRenderTarget(this.res,this.res,{type:a}),this.progressiveLightMap2=new o.WebGLRenderTarget(this.res,this.res,{type:a}),this.uvMat=new o.MeshPhongMaterial({shininess:0,specular:new o.Color("black")}),this.uniforms={},this.uvMat.onBeforeCompile=e=>{e.vertexShader="#define USE_LIGHTMAP\n"+e.vertexShader.slice(0,-1)+"\tgl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }";const t=e.fragmentShader.indexOf("void main() {");e.fragmentShader=e.fragmentShader.replace("#include <clipping_planes_pars_fragment>","#include <clipping_planes_pars_fragment>\n#include <shadowmask_pars_fragment>\n"),e.fragmentShader="varying vec2 vUv2;\n"+e.fragmentShader.slice(0,t)+"\tuniform sampler2D previousShadowMap;\n\tuniform float averagingWindow;\n"+e.fragmentShader.slice(t-1,-1)+"\nvec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n      }",e.uniforms.previousShadowMap={value:this.progressiveLightMap1.texture},e.uniforms.averagingWindow={value:100},this.uniforms=e.uniforms}}clear(){this.renderer.setRenderTarget(this.progressiveLightMap1),this.renderer.clear(),this.renderer.setRenderTarget(this.progressiveLightMap2),this.renderer.clear()}configureObject(e){const t=e.geometry.getAttribute("uv").clone();e.geometry.setAttribute("uv2",t),e.geometry.getAttribute("uv2").needsUpdate=!0}update(e,t=100){this.uniforms.averagingWindow={value:t},this.scene.overrideMaterial=this.uvMat;const r=this.buffer1Active?this.progressiveLightMap1:this.progressiveLightMap2,a=this.buffer1Active?this.progressiveLightMap2:this.progressiveLightMap1;this.renderer.setRenderTarget(r),this.uniforms.previousShadowMap={value:a.texture},this.buffer1Active=!this.buffer1Active,this.renderer.render(this.scene,e),this.scene.overrideMaterial=null,this.renderer.setRenderTarget(null)}}exports.AccumulativeShadows=c,exports.RandomizedLight=h,exports.accumulativeContext=l;
