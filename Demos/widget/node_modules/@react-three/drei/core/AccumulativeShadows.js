import _extends from '@babel/runtime/helpers/esm/extends';
import * as THREE from 'three';
import * as React from 'react';
import { useThree, useFrame } from '@react-three/fiber';

function isLight(object) {
  return object.isLight;
}

const accumulativeContext = /*#__PURE__*/React.createContext(null);
const AccumulativeShadows = /*#__PURE__*/React.forwardRef(({
  children,
  blend,
  frames = 40,
  scale = 10,
  temporal = false,
  opacity = 1,
  alphaTest = 0.65,
  color = 'black',
  resolution = 1024,
  ...props
}, forwardRef) => {
  const gl = useThree(state => state.gl);
  const scene = useThree(state => state.scene);
  const defaultCamera = useThree(state => state.camera);
  const gPlane = React.useRef(null);
  const gLights = React.useRef(null);
  const count = React.useRef(0);
  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));
  React.useLayoutEffect(() => {
    plm.configureObject(gPlane.current);
  }, []); // Actual number of frames to render, it must be at least 2 due to the ping/ponging in the lightmap

  if (frames <= 1) frames = 2;
  let blendFrames = blend === undefined ? frames === Infinity ? 100 : frames : frames;
  const material = React.useMemo(() => {
    const mat = Object.assign(new THREE.MeshBasicMaterial({
      opacity: 0,
      transparent: true,
      dithering: true,
      depthWrite: false,
      map: plm.progressiveLightMap2.texture
    }), {
      uniforms: {
        ucolor: {
          value: new THREE.Color(color)
        },
        alphaTest: {
          value: 0
        }
      }
    });

    mat.onBeforeCompile = shader => {
      mat.uniforms = shader.uniforms = { ...shader.uniforms,
        ...mat.uniforms
      };
      shader.fragmentShader = shader.fragmentShader.replace(`void main() {`, `uniform vec3 ucolor;
           uniform float alphaTest;
           void main() {`);
      shader.fragmentShader = shader.fragmentShader.replace('#include <dithering_fragment>', `#include <dithering_fragment>
           gl_FragColor = vec4(ucolor * gl_FragColor.r * 2.0, max(0.0, (1.0 - gl_FragColor.r / alphaTest)) * opacity);`);
    };

    return mat;
  }, [color]);
  const [lights, setLights] = React.useState([]);

  function update(frames = 1) {
    // Adapt the opacity-blend ratio to the number of frames
    if (!temporal) {
      material.opacity = opacity;
      material.uniforms.alphaTest.value = alphaTest;
    } else {
      material.opacity = Math.min(opacity, material.opacity + opacity / blendFrames);
      material.uniforms.alphaTest.value = Math.min(alphaTest, material.uniforms.alphaTest.value + alphaTest / blendFrames);
    } // Switch accumulative lights on


    gLights.current.visible = true; // Switch off all other scene lights off, collect their intensities

    const intensities = [];
    scene.traverse(object => {
      if (isLight(object)) {
        intensities.push({
          object,
          intensity: object.intensity
        });
        object.intensity = 0;
      }
    }); // Update the lightmap and the accumulative lights

    for (let i = 0; i < frames; i++) {
      plm.update(defaultCamera, blendFrames);
      if (lights) lights.forEach(light => light.update());
    } // Switch lights off


    gLights.current.visible = false; // Switch scene lights on and restore their intensities

    intensities.forEach(({
      object,
      intensity
    }) => object.intensity = intensity);
  }

  function reset() {
    if (frames !== Infinity) {
      plm.clear();
      material.opacity = 0;
      material.uniforms.alphaTest.value = 0;
      count.current = 0;
      update();
    }
  } // Expose api, allow children to set itself as the main light source


  const api = React.useMemo(() => ({
    reset,
    update,
    setLights
  }), []);
  React.useImperativeHandle(forwardRef, () => api, [api]);
  useFrame(() => {
    if (temporal && count.current < frames) {
      update();
      count.current++;
    }
  });
  React.useLayoutEffect(() => {
    reset();
    if (!temporal) update(blendFrames);
  });
  return /*#__PURE__*/React.createElement("group", props, /*#__PURE__*/React.createElement("group", {
    traverse: () => null,
    ref: gLights
  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {
    value: api
  }, children)), /*#__PURE__*/React.createElement("mesh", {
    receiveShadow: true,
    ref: gPlane,
    material: material,
    scale: scale,
    rotation: [-Math.PI / 2, 0, 0]
  }, /*#__PURE__*/React.createElement("planeGeometry", null)));
});
const RandomizedLight = /*#__PURE__*/React.forwardRef(({
  castShadow = true,
  bias = 0,
  mapSize = 512,
  size = 5,
  near = 0.5,
  far = 500,
  frames = 1,
  position = [0, 0, 0],
  radius = 1,
  amount = 8,
  intensity = 1,
  ambient = 0.5,
  ...props
}, forwardRef) => {
  const gLights = React.useRef(null);
  const length = new THREE.Vector3(...position).length();
  const parent = React.useContext(accumulativeContext);
  const update = React.useCallback(() => {
    let light;

    if (gLights.current) {
      for (let l = 0; l < gLights.current.children.length; l++) {
        light = gLights.current.children[l];

        if (Math.random() > ambient) {
          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));
        } else {
          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;
          let phi = 2 * Math.PI * Math.random();
          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);
        }
      }
    }
  }, [radius, ambient, length, ...position]);
  const api = React.useMemo(() => ({
    update
  }), [update]);
  React.useImperativeHandle(forwardRef, () => api, [api]);
  React.useLayoutEffect(() => {
    if (parent) parent.setLights(state => [...state, api]);
    return () => parent.setLights(state => state.filter(a => a !== api));
  }, [parent, api]);
  return /*#__PURE__*/React.createElement("group", _extends({
    ref: gLights
  }, props), Array.from({
    length: amount
  }, (_, index) => /*#__PURE__*/React.createElement("directionalLight", {
    key: index,
    castShadow: castShadow,
    "shadow-bias": bias,
    "shadow-mapSize": [mapSize, mapSize],
    intensity: intensity / amount
  }, /*#__PURE__*/React.createElement("orthographicCamera", {
    attach: "shadow-camera",
    args: [-size, size, size, -size, near, far]
  }))));
}); // Based on "Progressive Light Map Accumulator", by [zalo](https://github.com/zalo/)

class ProgressiveLightMap {
  constructor(renderer, scene, res = 1024) {
    this.renderer = renderer;
    this.res = res;
    this.scene = scene;
    this.scene.background = null;
    this.buffer1Active = false; // Create the Progressive LightMap Texture

    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;
    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, {
      type: format
    });
    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, {
      type: format
    }); // Inject some spicy new logic into a standard phong material

    this.uvMat = new THREE.MeshPhongMaterial({
      shininess: 0,
      specular: new THREE.Color('black')
    });
    this.uniforms = {};

    this.uvMat.onBeforeCompile = shader => {
      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions
      shader.vertexShader = '#define USE_LIGHTMAP\n' + shader.vertexShader.slice(0, -1) + '	gl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows

      const bodyStart = shader.fragmentShader.indexOf('void main() {');
      shader.fragmentShader = shader.fragmentShader.replace('#include <clipping_planes_pars_fragment>', '#include <clipping_planes_pars_fragment>\n#include <shadowmask_pars_fragment>\n');
      shader.fragmentShader = 'varying vec2 vUv2;\n' + shader.fragmentShader.slice(0, bodyStart) + '	uniform sampler2D previousShadowMap;\n	uniform float averagingWindow;\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\nvec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;
        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);
      }`; // Set the Previous Frame's Texture Buffer and Averaging Window

      shader.uniforms.previousShadowMap = {
        value: this.progressiveLightMap1.texture
      };
      shader.uniforms.averagingWindow = {
        value: 100
      };
      this.uniforms = shader.uniforms;
    };
  }

  clear() {
    this.renderer.setRenderTarget(this.progressiveLightMap1);
    this.renderer.clear();
    this.renderer.setRenderTarget(this.progressiveLightMap2);
    this.renderer.clear();
  }

  configureObject(object) {
    const uv2 = object.geometry.getAttribute('uv').clone();
    object.geometry.setAttribute('uv2', uv2);
    object.geometry.getAttribute('uv2').needsUpdate = true;
  }

  update(camera, blendWindow = 100) {
    // Set each object's material to the UV Unwrapped Surface Mapping Version
    this.uniforms.averagingWindow = {
      value: blendWindow
    };
    this.scene.overrideMaterial = this.uvMat; // Ping-pong two surface buffers for reading/writing

    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;
    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps

    this.renderer.setRenderTarget(activeMap);
    this.uniforms.previousShadowMap = {
      value: inactiveMap.texture
    };
    this.buffer1Active = !this.buffer1Active;
    this.renderer.render(this.scene, camera);
    this.scene.overrideMaterial = null;
    this.renderer.setRenderTarget(null);
  }

}

export { AccumulativeShadows, RandomizedLight, accumulativeContext };
